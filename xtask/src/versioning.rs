// Versioning infrastructure
// This generates the SEMVER data that is displayed when querying `xous ver`
// It also generates timestamps, if demanded.

use std::fs::OpenOptions;
use std::io::Write;
use std::process::Command;

use chrono::{Local, TimeZone, Utc};

/// Fixed abbreviation length for `git describe` output.
/// Ensures consistent version strings regardless of clone depth.
const GIT_ABBREV_LEN: u8 = 9;

fn write_if_changed(path: &str, new_data: &[u8]) {
    if let Ok(existing) = std::fs::read(path) {
        if existing == new_data {
            return;
        }
    }
    let mut vfile = OpenOptions::new()
        .write(true)
        .create(true)
        .truncate(true)
        .open(path)
        .expect(&format!("Can't open {} for writing", path));
    vfile.write_all(new_data).expect(&format!("couldn't write to {}", path));
}

pub(crate) fn generate_version(
    add_timestamp: bool,
    forced_version: Option<String>,
    baobit_commit: Option<String>,
) {
    let gitver = {
        if let Some(ver) = forced_version {
            ver.as_bytes().to_vec()
        } else {
            let cmd = format!("git describe --long --abbrev={}", GIT_ABBREV_LEN);
            let output = if cfg!(target_os = "windows") {
                Command::new("cmd").args(["/C", &cmd]).output().expect("failed to execute process")
            } else {
                Command::new("sh").arg("-c").arg(&cmd).output().expect("failed to execute process")
            };
            output.stdout
        }
    };
    let semver = String::from_utf8_lossy(&gitver);

    let version_file = "services/xous-ticktimer/src/version.rs";
    let boot0_version_file = "bao1x-boot/boot0/src/version.rs";
    let boot1_version_file = "bao1x-boot/boot1/src/version.rs";

    let mut new_data = Vec::new();
    print_header(&mut new_data);
    if add_timestamp {
        // Use SOURCE_DATE_EPOCH for reproducible builds if available
        // See: https://reproducible-builds.org/docs/source-date-epoch/
        let timestamp_str = if let Ok(sde) = std::env::var("SOURCE_DATE_EPOCH") {
            let secs: i64 = sde.parse().expect("SOURCE_DATE_EPOCH must be a valid Unix timestamp");
            Utc.timestamp_opt(secs, 0).single().expect("Invalid SOURCE_DATE_EPOCH timestamp").to_rfc2822()
        } else {
            Local::now().to_rfc2822()
        };
        write!(new_data, "#[allow(dead_code)]\npub const TIMESTAMP: &'static str = \"{}\";\n", timestamp_str)
            .expect("couldn't add our timestamp");
    } else {
        write!(new_data, "#[allow(dead_code)]\npub const TIMESTAMP: &'static str = \"omitted\";\n")
            .expect("couldn't add our timestamp");
    }
    let mut semver_code = Vec::new();
    writeln!(
        semver_code,
        "pub const SEMVER: &'static str = \"{}\";",
        semver.strip_suffix("\r\n").or(semver.strip_suffix('\n')).unwrap_or(&semver)
    )
    .expect("couldn't add our semver");
    new_data.extend_from_slice(&semver_code);

    // Baochip versioning is just SEMVER + BAOBIT_COMMIT. Now that
    // the semver_code has been added to new_data, we can extend it with the Baobit commit.
    if let Some(ref commit) = baobit_commit {
        writeln!(semver_code, "pub const BAOBIT_COMMIT: &'static str = \"{}\";", commit)
            .expect("couldn't add baobit commit");
    } else {
        // For builds that aren't built in the reproducible environment, the baobit commit is unspecified
        writeln!(semver_code, "pub const BAOBIT_COMMIT: &'static str = \"unspecified\";")
            .expect("couldn't add baobit commit placeholder");
    }

    write_if_changed(version_file, &new_data);
    write_if_changed(boot0_version_file, &semver_code);
    write_if_changed(boot1_version_file, &semver_code);
}

fn print_header<U: Write>(out: &mut U) {
    let s = r####"#![cfg_attr(rustfmt, rustfmt_skip)]
// Versioning information is kept in a separate file, attached to a small, well-known server in the Xous System
// This is a trade-off between rebuild times and flexibility.
// This was autogenerated by xtask/src/main.rs:print_header(). Do not edit manually.

pub(crate) fn get_version() -> crate::api::VersionString {
    let mut v = crate::api::VersionString {
        version: String::new()
    };
    v.version.push_str(SEMVER);
    v.version.push_str("\n");
    v.version.push_str(TIMESTAMP);
    v
}
"####;
    out.write_all(s.as_bytes()).expect("couldn't write our version template header");
}
