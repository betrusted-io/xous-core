/*
 * fp_q16.h - Fixed-point math library
 *
 * Format: configurable Q format via FP_FRAC_BITS
 * Default: Q16.16 (16 integer bits, 16 fractional bits)
 *
 * Representation: signed 32-bit integer
 * Range (Q16.16): -32768.0 to +32767.99999
 * Resolution:      1/65536 ~= 0.0000153
 *
 * Cosine is computed via CORDIC (rotation mode, 16 iterations) rather than
 * a lookup table.  Effective precision is ~15 ulp, substantially better than
 * the 64-entry table used in the Q12 version.
 */

#ifndef FP_H
#define FP_H

#include <stdint.h>
#include <stddef.h>

/* --- Configuration --- */

#ifndef FP_FRAC_BITS
#define FP_FRAC_BITS 16
#endif

#define FP_ONE  (1 << FP_FRAC_BITS)
#define FP_MASK (FP_ONE - 1)

typedef int32_t fp_t;

/* --- Constants ---
 *
 * All computed at compile time from integer literals.
 *
 * At Q16 (FP_ONE = 65536):
 *   PI      = round(3.14159265358979 * 65536) = 205887
 *   TWO_PI  = 411775
 *   HALF_PI = 102944
 */
#define FP_PI      ((fp_t)(3.14159265358979f * FP_ONE + 0.5f))
#define FP_TWO_PI  ((fp_t)(6.28318530717959f * FP_ONE + 0.5f))
#define FP_HALF_PI ((fp_t)(1.57079632679490f * FP_ONE + 0.5f))

/* --- Conversion --- */

#define FP_FROM_INT(x)   ((fp_t)((x) << FP_FRAC_BITS))
#define FP_TO_INT(x)     ((int32_t)((x) >> FP_FRAC_BITS))
#define FP_FROM_FLOAT(x) ((fp_t)((x) * FP_ONE + 0.5f))
#define FP_TO_FLOAT(x)   ((float)(x) / FP_ONE)

/* --- Arithmetic --- */

static inline fp_t fp_add(fp_t a, fp_t b)
{
    return a + b;
}

static inline fp_t fp_sub(fp_t a, fp_t b)
{
    return a - b;
}

/*
 * fp_mul - fixed-point multiply using RISC-V mulh/mul pair.
 *
 * Reconstructs the full 64-bit product from the high (mulh) and low (mul)
 * 32-bit words, then shifts right by FP_FRAC_BITS to re-align the binary
 * point.  The early-clobber on 'hi' (&) prevents the compiler from aliasing
 * it with an input register.
 */

static inline fp_t fp_mul(fp_t a, fp_t b)
{
    int64_t result = (int64_t)a * (int64_t)b;
    return (fp_t)(result >> FP_FRAC_BITS);
}

/*
 * u32_divrem - unsigned 32-bit shift-and-subtract divider.
 *
 * 32 iterations of: shift one bit of the dividend into the partial
 * remainder, subtract the divisor if it fits, record the quotient bit.
 * No hardware divide instruction required.
 */
static inline uint32_t u32_divrem(uint32_t dividend, uint32_t divisor,
                                  uint32_t *remainder)
{
    uint32_t quotient = 0;
    uint32_t rem      = 0;
    int      i;

    for (i = 31; i >= 0; i--) {
        rem = (rem << 1) | ((dividend >> i) & 1);
        if (rem >= divisor) {
            rem      -= divisor;
            quotient |= (1u << i);
        }
    }

    if (remainder) *remainder = rem;
    return quotient;
}

/*
 * fp_div - signed fixed-point division, no hardware divide.
 *
 * Works in two passes through u32_divrem:
 *   pass 1: integer quotient and remainder of |a| / |b|
 *   pass 2: fractional bits from (remainder << FP_FRAC_BITS) / |b|
 * Sign is restored at the end.
 */
static inline fp_t fp_div(fp_t a, fp_t b)
{
    int32_t  sign = ((a ^ b) < 0) ? -1 : 1;
    uint32_t ua   = (uint32_t)(a < 0 ? -a : a);
    uint32_t ub   = (uint32_t)(b < 0 ? -b : b);
    uint32_t q, r;
    fp_t     res;

    q   = u32_divrem(ua, ub, &r);
    res = (fp_t)((q << FP_FRAC_BITS) | u32_divrem(r << FP_FRAC_BITS, ub, NULL));

    return sign < 0 ? -res : res;
}

/* --- CORDIC cosine --- */

/*
 * CORDIC rotation-mode overview
 * ==============================
 * At each step i (0 .. N-1) we rotate a 2-D vector (x, y) by ±atan(2^-i):
 *
 *   x' = x - d * (y >> i)
 *   y' = y + d * (x >> i)      d = +1 if remaining angle > 0, else -1
 *   z' = z - d * atan_table[i]
 *
 * Starting with (x,y,z) = (K, 0, target_angle), after N iterations:
 *   x  ≈  cos(target_angle)   (in Q16, scaled by FP_ONE)
 *   y  ≈  sin(target_angle)
 *
 * where K = 1 / prod_{i=0}^{N-1} sqrt(1 + 2^{-2i}) is the CORDIC gain
 * pre-applied to the initial x so the output is already unit-scaled.
 *
 * Number of iterations
 * --------------------
 * 16 iterations give ~16 bits of precision, matching FP_FRAC_BITS = 16.
 * Each iteration adds roughly one bit of accuracy.
 *
 * atan table (Q16)
 * ----------------
 * atan_table[i] = round( atan(2^-i) * 65536 )
 *
 * Generated by:
 *   import math
 *   Q = 65536
 *   [round(math.atan(2**-i) * Q) for i in range(16)]
 *
 *   i=0:  atan(1)      = 0.7853982 -> 51472
 *   i=1:  atan(0.5)    = 0.4636476 -> 30386
 *   i=2:  atan(0.25)   = 0.2449787 -> 16055
 *   i=3:  atan(0.125)  = 0.1243550 ->  8150
 *   ...
 *
 * CORDIC gain K (Q16)
 * --------------------
 * K = prod_{i=0}^{15} 1/sqrt(1 + 2^{-2i})  ~= 0.60725293500888
 * K_Q16 = round(0.60725293500888 * 65536)   = 39797
 */

#define CORDIC_ITERATIONS 16

static const int32_t cordic_atan_table[CORDIC_ITERATIONS] = {
    51472, 30386, 16055, 8150, 4091, 2047, 1024, 512,
    256,   128,   64,    32,   16,   8,    4,    2
};

/*
 * CORDIC gain K in Q16.
 *
 * K = 1 / prod_{i=0}^{15} sqrt(1 + 2^{-2i})
 *   = 0.6072529350088812561...
 * round(K * 65536) = 39797
 *
 * We start the CORDIC vector at (K_Q16, 0) so that the output x is already
 * in Q16 with magnitude cos(angle), no post-multiply needed.
 */
#define CORDIC_K_Q16  ((int32_t)39797)

/*
 * fp_cos_cordic - internal CORDIC rotation for angle in [0, pi/2].
 *
 * Input:  angle in Q16, must be in [0, FP_HALF_PI].
 * Output: cos(angle) in Q16.
 *
 * The initial vector is (K, 0) with K pre-scaled by FP_ONE so all
 * arithmetic stays in integer Q16 throughout.
 */
static inline fp_t fp_cos_cordic(fp_t angle)
{
    int32_t x = CORDIC_K_Q16;
    int32_t y = 0;
    int32_t z = angle;
    int     i;

    for (i = 0; i < CORDIC_ITERATIONS; i++) {
        int32_t dx = y >> i;
        int32_t dy = x >> i;
        if (z >= 0) {
            /* Rotate counter-clockwise: subtract angle step */
            x -= dx;
            y += dy;
            z -= cordic_atan_table[i];
        } else {
            /* Rotate clockwise: add angle step */
            x += dx;
            y -= dy;
            z += cordic_atan_table[i];
        }
    }

    return (fp_t)x;
}

/*
 * fp_cos - cosine of x (angle in Q16 radians).
 *
 * Symmetry used to cover the full circle from [0, pi/2]:
 *   [0,     pi/2]:  cos(x)        -> CORDIC direct
 *   [pi/2,  pi]:    cos(pi - x)   -> CORDIC, result negated
 *   [pi,  3pi/2]:   cos(x - pi)   -> same as [0, pi/2] by symmetry, negated
 *   [3pi/2, 2pi]:   cos(2pi - x)  -> CORDIC direct
 *
 * Range reduction for large magnitudes uses integer period counting
 * (one division by 2*pi) to avoid slow repeated subtraction loops.
 */
static inline fp_t fp_cos(fp_t x)
{
    int32_t negate = 0;

    /* --- Range-reduce to [0, 2*pi) --- */
    if (x < 0) {
        /* cos is even: cos(-x) = cos(x) */
        x = -x;
    }
    if (x >= FP_TWO_PI) {
        /* Integer number of full periods to subtract.
         * fp_div is used here; for performance-critical paths the caller
         * should pre-reduce the angle. */
        int32_t periods = FP_TO_INT(fp_div(x, FP_TWO_PI));
        x -= (fp_t)(periods * FP_TWO_PI);
        /* Guard against rounding pushing x back over 2pi */
        if (x >= FP_TWO_PI) x -= FP_TWO_PI;
    }

    /* --- Quadrant reduction to [0, pi/2] --- */

    /* [pi, 2pi] -> [0, pi]:  cos(2pi - x) = cos(x) */
    if (x > FP_PI) {
        x = FP_TWO_PI - x;
    }

    /* [pi/2, pi] -> [0, pi/2]:  cos(pi - x) = -cos(x) */
    if (x > FP_HALF_PI) {
        x      = FP_PI - x;
        negate = 1;
    }

    /* --- CORDIC in [0, pi/2] --- */
    fp_t result = fp_cos_cordic(x);

    return negate ? -result : result;
}

#endif /* FP_H */