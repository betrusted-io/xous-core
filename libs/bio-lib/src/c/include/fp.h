/*
 * fp.h - Fixed-point math library
 *
 * Format: configurable Q format via FP_FRAC_BITS
 * Default: Q20.12 (20 integer bits, 12 fractional bits)
 *
 * Representation: signed 32-bit integer
 * Range (Q20.12): -524288.0 to +524287.9998
 * Resolution:      1/4096 ~= 0.000244
 */

#ifndef FP_H
#define FP_H

#include <stdint.h>
#include <stddef.h>

/* --- Configuration --- */

#ifndef FP_FRAC_BITS
#define FP_FRAC_BITS 12
#endif

#define FP_ONE  (1 << FP_FRAC_BITS)
#define FP_MASK (FP_ONE - 1)

typedef int32_t fp_t;

/* --- Constants ---
 *
 * All computed at compile time from integer literals so the preprocessor
 * never emits a divide or a float-to-int conversion at runtime.
 *
 * At Q12 (FP_ONE = 4096):
 *   PI      = round(3.14159265 * 4096) = 12868
 *   TWO_PI  = 25736
 *   HALF_PI = 6434   (== PI/2, exact: 3.14159265/2*4096 = 6433.98 -> 6434)
 */
#define FP_PI      ((fp_t)(3.14159265f * FP_ONE + 0.5f))
#define FP_TWO_PI  ((fp_t)(6.28318530f * FP_ONE + 0.5f))
#define FP_HALF_PI ((fp_t)(1.57079632f * FP_ONE + 0.5f))

/* --- Conversion --- */

#define FP_FROM_INT(x)   ((fp_t)((x) << FP_FRAC_BITS))
#define FP_TO_INT(x)     ((int32_t)((x) >> FP_FRAC_BITS))
#define FP_FROM_FLOAT(x) ((fp_t)((x) * FP_ONE + 0.5f))
#define FP_TO_FLOAT(x)   ((float)(x) / FP_ONE)

/* --- Arithmetic --- */

static inline fp_t fp_add(fp_t a, fp_t b)
{
    return a + b;
}

static inline fp_t fp_sub(fp_t a, fp_t b)
{
    return a - b;
}

/*
 * fp_mul - fixed-point multiply using RISC-V mulh/mul pair.
 *
 * Reconstructs the full 64-bit product from the high (mulh) and low (mul)
 * 32-bit words, then shifts right by FP_FRAC_BITS to re-align the binary
 * point. The early-clobber on 'hi' (&) prevents the compiler from aliasing
 * it with an input register.
 */
static inline fp_t fp_mul(fp_t a, fp_t b)
{
    int32_t hi, lo;
    __asm__ (
        "mulh  %0, %2, %3\n"
        "mul   %1, %2, %3\n"
        : "=&r"(hi), "=r"(lo)
        : "r"(a),    "r"(b)
    );
    return (fp_t)(((uint32_t)hi << (32 - FP_FRAC_BITS)) |
                  ((uint32_t)lo >>  FP_FRAC_BITS));
}

/*
 * u32_divrem - unsigned 32-bit shift-and-subtract divider.
 *
 * 32 iterations of: shift one bit of the dividend into the partial
 * remainder, subtract the divisor if it fits, record the quotient bit.
 * No hardware divide instruction required.
 */
static inline uint32_t u32_divrem(uint32_t dividend, uint32_t divisor,
                                  uint32_t *remainder)
{
    uint32_t quotient = 0;
    uint32_t rem      = 0;
    int      i;

    for (i = 31; i >= 0; i--) {
        rem = (rem << 1) | ((dividend >> i) & 1);
        if (rem >= divisor) {
            rem      -= divisor;
            quotient |= (1u << i);
        }
    }

    if (remainder) *remainder = rem;
    return quotient;
}

/*
 * fp_div - signed fixed-point division, no hardware divide.
 *
 * Works in two passes through u32_divrem:
 *   pass 1: integer quotient and remainder of |a| / |b|
 *   pass 2: fractional bits from (remainder << FP_FRAC_BITS) / |b|
 * Sign is restored at the end.
 *
 * Note: r << FP_FRAC_BITS is safe because r < ub after pass 1, and
 * ub is a Q12 value so fits comfortably within 32 bits after the shift.
 */
static inline fp_t fp_div(fp_t a, fp_t b)
{
    int32_t  sign = ((a ^ b) < 0) ? -1 : 1;
    uint32_t ua   = (uint32_t)(a < 0 ? -a : a);
    uint32_t ub   = (uint32_t)(b < 0 ? -b : b);
    uint32_t q, r;
    fp_t     res;

    q   = u32_divrem(ua, ub, &r);
    res = (fp_t)((q << FP_FRAC_BITS) | u32_divrem(r << FP_FRAC_BITS, ub, NULL));

    return sign < 0 ? -res : res;
}

/* --- Trigonometry --- */

#define COS_TABLE_ENTRIES 64

/*
 * Lookup table for cos(i/64 * pi/2) in Q12, i = 0..64.
 *
 * Generated by:
 *   import math
 *   N, Q = 64, 4096
 *   [round(math.cos(i/N * math.pi/2) * Q) for i in range(N+1)]
 *
 * Covers one quadrant [0, pi/2]; the other three are handled by symmetry.
 * Values fit in int16_t (max 4096 <= 32767).
 */
static const int16_t cos_table[COS_TABLE_ENTRIES + 1] = {
    4096, 4096, 4095, 4094, 4092, 4090, 4087, 4083,
    4078, 4073, 4067, 4060, 4052, 4044, 4035, 4025,
    4014, 4003, 3991, 3978, 3964, 3950, 3935, 3919,
    3902, 3885, 3867, 3848, 3828, 3807, 3786, 3764,
    3741, 3718, 3694, 3669, 3643, 3617, 3590, 3563,
    3535, 3506, 3477, 3447, 3417, 3386, 3354, 3322,
    3289, 3256, 3222, 3188, 3153, 3118, 3082, 3046,
    3009, 2972, 2935, 2897, 2859, 2820, 2781, 2742,
    2702
};

/*
 * fp_cos - cosine via table lookup + linear interpolation.
 *
 * Symmetry used to cover the full circle from the [0, pi/2] table:
 *   [0,     pi/2]:  cos(x)           -> table forward
 *   [pi/2,  pi]:    cos(pi - x)      -> table forward, negated
 *   [pi,  3pi/2]:   cos(x - pi)      -> same as above by symmetry
 *   [3pi/2, 2pi]:   cos(2pi - x)     -> table forward
 *
 * Range reduction uses only addition/subtraction (no divide).
 * The single fp_div call inside scales x to a table index.
 *
 * FP_HALF_PI, FP_PI, FP_TWO_PI are all compile-time constants so no
 * runtime divide is emitted for them.
 */
static inline fp_t fp_cos(fp_t x)
{
    int32_t negate = 0;
    int32_t idx;
    fp_t    offset, frac, lo, hi;

    /* --- Range-reduce to [0, 2*pi) using only add/subtract --- */
    /* Handle large negative values first */
    if (x < 0) {
        /* How many full 2*pi below zero? Round up, then add. */
        int32_t periods = FP_TO_INT(-x) / FP_TO_INT(FP_TWO_PI) + 1;
        x += (fp_t)(periods * FP_TWO_PI);
    }
    /* Handle large positive values */
    while (x >= FP_TWO_PI) {
        x -= FP_TWO_PI;
    }

    /* --- Quadrant reduction to [0, pi/2] --- */

    /* [pi, 2*pi] -> [0, pi]:  cos(2pi - x) = cos(x), no sign change */
    if (x > FP_PI) {
        x = FP_TWO_PI - x;
    }

    /* [pi/2, pi] -> [0, pi/2]: cos(pi - x) = -cos(x), flip sign */
    if (x > FP_HALF_PI) {
        x      = FP_PI - x;
        negate = 1;
    }

    /* --- Scale x in [0, pi/2] to a table index in [0, 64] --- */
    /*
     * offset = x / (pi/2) * 64
     *        = x * 64 / HALF_PI
     *
     * x <= HALF_PI = 6434, so x * 64 <= 411776, well within int32_t.
     * We do the multiply first (shift left 6) then divide, keeping
     * everything in fixed-point so the result is still Q12.
     */
    offset = fp_div(x << 6, FP_HALF_PI);   /* result in Q12, range [0, 64<<12] */

    idx  = FP_TO_INT(offset);              /* integer table index, 0..64 */
    frac = offset & FP_MASK;              /* fractional part for lerp, Q12    */

    /* Clamp: x == pi/2 exactly maps to index 64, which is the last entry */
    if (idx >= COS_TABLE_ENTRIES) {
        idx  = COS_TABLE_ENTRIES - 1;
        frac = FP_ONE;
    }

    /* --- Linear interpolation between adjacent table entries --- */
    lo     = (fp_t)cos_table[idx];
    hi     = (fp_t)cos_table[idx + 1];
    offset = lo + fp_mul(hi - lo, frac);   /* result is Q12 */

    return negate ? -offset : offset;
}

#endif /* FP_H */